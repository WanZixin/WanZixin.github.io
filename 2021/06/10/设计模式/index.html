<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>设计模式 - WanZixin</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">




<meta name="description" content="">





    <meta name="description" content="设计模式，即Design Patterns，是指在软件设计中，被反复使用的代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="https://wanzixin.github.io/2021/06/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="WanZixin">
<meta property="og:description" content="设计模式，即Design Patterns，是指在软件设计中，被反复使用的代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-06-10T10:54:11.000Z">
<meta property="article:modified_time" content="2021-06-14T03:28:38.999Z">
<meta property="article:author" content="WanZixin">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                    
                    WanZixin
                    
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/archives">Archives</a>
            
            <a class="navbar-item "
               href="/categories">Categories</a>
            
            <a class="navbar-item "
               href="/categories/Diary">Diary</a>
            
            <a class="navbar-item "
               href="/categories/Gallery">Gallery</a>
            
            <a class="navbar-item "
               href="/categories/Study">Study</a>
            
            <a class="navbar-item "
               href="/categories/Item">Item</a>
            
            <a class="navbar-item "
               href="/about">About</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="Search" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            <div class="navbar-item is-hoverable has-dropdown is-hidden-mobile is-hidden-tablet-only toc">
                <a class="navbar-item" title="Table of Contents">
                    <i class="fa fa-list"></i>
                </a>
                <div class="navbar-dropdown is-right">
                    
                    
                    
                    
                    <a class="navbar-item" href="#概述">1&nbsp;&nbsp;<b>概述</b></a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#创建型模式">2&nbsp;&nbsp;<b>创建型模式</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#工厂方法">2.1&nbsp;&nbsp;工厂方法</a>
                    
                    
                    
                    <a class="navbar-item" href="#小结">2.1.1&nbsp;&nbsp;小结</a>
                    
                    
                    
                    <a class="navbar-item" href="#抽象工厂">2.2&nbsp;&nbsp;抽象工厂</a>
                    
                    
                    
                    <a class="navbar-item" href="#生成器">2.3&nbsp;&nbsp;生成器</a>
                    
                    
                    
                    <a class="navbar-item" href="#原型">2.4&nbsp;&nbsp;原型</a>
                    
                    
                    
                    <a class="navbar-item" href="#单例">2.5&nbsp;&nbsp;单例</a>
                    
                    
                    
                    <a class="navbar-item" href="#小结-1">2.5.1&nbsp;&nbsp;小结</a>
                    
                    
                    <hr class="navbar-divider">
                    
                    
                    <a class="navbar-item" href="#结构型模式">3&nbsp;&nbsp;<b>结构型模式</b></a>
                    
                    
                    
                    <a class="navbar-item" href="#适配器">3.1&nbsp;&nbsp;适配器</a>
                    
                    
                    
                    <a class="navbar-item" href="#小结-2">3.1.1&nbsp;&nbsp;小结</a>
                    
                    
                    
                    <a class="navbar-item" href="#桥接">3.2&nbsp;&nbsp;桥接</a>
                    
                    
                    
                    <a class="navbar-item" href="#组合">3.3&nbsp;&nbsp;组合</a>
                    
                    
                    
                    <a class="navbar-item" href="#装饰器">3.4&nbsp;&nbsp;装饰器</a>
                    
                    
                    
                    <a class="navbar-item" href="#外观">3.5&nbsp;&nbsp;外观</a>
                    
                    
                    
                    <a class="navbar-item" href="#享元">3.6&nbsp;&nbsp;享元</a>
                    
                    
                    
                    <a class="navbar-item" href="#代理">3.7&nbsp;&nbsp;代理</a>
                    
                    
                    
                    <a class="navbar-item" href="#远程代理">3.7.1&nbsp;&nbsp;远程代理</a>
                    
                    
                    
                    <a class="navbar-item" href="#虚代理">3.7.2&nbsp;&nbsp;虚代理</a>
                    
                    
                    
                    <a class="navbar-item" href="#保护代理">3.7.3&nbsp;&nbsp;保护代理</a>
                    
                    
                    
                    <a class="navbar-item" href="#智能引用">3.7.4&nbsp;&nbsp;智能引用</a>
                    
                    
                    
                    <a class="navbar-item" href="#小结-3">3.7.5&nbsp;&nbsp;小结</a>
                    
                </div>
            </div>
            
            
            <a class="navbar-item" title="GitHub" target="_blank" rel="noopener" href="https://github.com/wanzixin">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            设计模式
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            
                <span>Jun 10 2021</span>
            
        </span>
        
        <span class="column is-narrow article-category">
            <i class="far fa-folder"></i>
            <a class="article-category-link" href="/categories/Study/">Study</a><span>></span><a class="article-category-link" href="/categories/Study/Java/">Java</a>
        </span>
        
        
        <span class="column is-narrow">
            
            
            an hour read (About 9205 words)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。<span id="more"></span></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：</p>
<ol>
<li>开闭原则。开闭原则（Open Closed Principle）是指，软件应该对扩展开放，而对修改关闭。这里的意思是，在增加新功能时，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</li>
<li>里氏替换原则。里氏替换原则是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</li>
</ol>
<p>设计模式是把一些常用的设计模式提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF（提出设计模式这个术语的四个人）把23个常用模式分为创建型模式、结构型模式和行为型模式三类。学习设计模式，关键的是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计的复杂性和灵活性，并意识到设计模式也不是万能的。</p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式关注点是如何创建对象，其核心思想是把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。工厂方法即Factory Method，是一种对象创建型模式。工厂方法的目的是使得创建对象和使用对象是想分离的，并且客户端总是引用抽象工厂和抽象产品。</p>
<p>我们来举个例子，假设我们希望实现一个解析字符串到<code>Number</code>的<code>Factory</code>，可以这么定义。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NumberFactory</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 创建方法:</span></span><br><span class="line">    <span class="hljs-function">Number <span class="hljs-title">parse</span><span class="hljs-params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 获取工厂实例:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">static</span> NumberFactory <span class="hljs-title">getFactory</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> impl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> NumberFactory impl = <span class="hljs-keyword">new</span> NumberFactoryImpl();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端如何创建<code>NumberFactoryImpl</code>呢？通常我们会在接口<code>Factory</code>中定义一个静态方法<code>getFactory()</code>来返回真正的子类。</p>
<p>有了工厂接口，再编写一个工厂的实现类。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberFactoryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NumberFactory</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Number <span class="hljs-title">parse</span><span class="hljs-params">(String s)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>产品接口是<code>Number</code>，<code>NumberFactoryImpl</code>返回的实际产品是<code>BigDecimal</code>。</p>
<p>在客户端中，我们只需要和工厂接口<code>NumberFactory</code>以及抽象产品<code>Number</code>打交道。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NumberFactory factory = NumberFactory.getFactory();</span><br><span class="line">Number result = factory.parse(<span class="hljs-string">"123.456"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>调用方可以完全忽略真正的工厂<code>NumberFactoryImpl</code>和实际产品<code>BigDecimal</code>，这样做的好处是允许创建产品的代码独立地变化，而不会影响到调用方。</p>
<p>有的同学就会问了：一个简单的<code>parse()</code>需要写这么复杂的工厂吗？实际上，大多数情况下，我们并不需要抽象工厂，而是通过静态方法直接返回产品，即：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberFactory</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Number <span class="hljs-title">parse</span><span class="hljs-params">(String s)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种简化的使用静态方法创建产品的方式，称为静态工厂方法（Static Factory Method）。静态工厂方法广泛应用在Java标准库中，例如：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer n = Integer.valueOf(<span class="hljs-number">100</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><code>Integer</code>既是产品也是静态工厂。它提供了静态方法<code>valueOf()</code>来创建<code>Integer</code>，那么，这种方式和直接使用<code>new</code>操作符有何区别？使用静态方法的好处在于，<code>valueOf()</code>内部可能会使用<code>new</code>创建一个新的<code>Integer</code>实例，也可能直接返回一个缓存的<code>Integer</code>实例，此时会减少内存消耗提升速度。对调用方来说没必要在意这些细节。而如果调用方直接使用new操作符，那么就失去了使用缓存优化的可能性。</p>
<p>我们经常使用的另一个静态工厂方法是<code>List.of()</code>，这个静态工厂方法可以接收可变参数，然后返回List接口。需要注意的是，调用方获取的产品总是<code>List</code>接口，而且并不关心它的实际类型。即使调用方知道<code>List</code>产品的实际类型是<code>java.util.ImmutableCollections$ListN</code>，也不要去强制转型为子类，因为静态工厂方法<code>List.of()</code>保证返回<code>List</code>，但也完全可以修改为返回<code>java.util.ArrayList</code>。</p>
<blockquote>
<p>总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向对象编程</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>工厂方法是指定义工厂接口和产品接口，但如何创建实际工厂和实际产品被推迟到子类实现，从而使调用方只和抽象工厂与抽象产品打交道。</p>
<p>实际更常用的是更简单的静态工厂方法，它允许工厂内部对创建产品进行优化。</p>
<p>调用方尽量持有接口或抽象类，避免持有具体类型的子类，以便工厂方法能随时切换不同的子类返回，却不影响调用方代码。</p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品。</p>
<p>这类似于多个供应商提供相类似产品。我们举个例子：假设我们希望为用户提供一个Markdown文本转换为HTML和Word的服务，它的接口定义如下：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 创建Html文档:</span></span><br><span class="line">    <span class="hljs-function">HtmlDocument <span class="hljs-title">createHtml</span><span class="hljs-params">(String md)</span></span>;</span><br><span class="line">    <span class="hljs-comment">// 创建Word文档:</span></span><br><span class="line">    <span class="hljs-function">WordDocument <span class="hljs-title">createWord</span><span class="hljs-params">(String md)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的抽象工厂仅仅是一个接口，没有任何代码。同样的，因为HtmlDocument和WordDocument都比较复杂，现在我们并不知道如何实现它们，所以只有接口：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Html文档接口:</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HtmlDocument</span> </span>{</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">toHtml</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Word文档接口:</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WordDocument</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样，我们就定义好了抽象工厂AbstractFactory和两个抽象产品HtmlDocument和WordDocument。实现它们比较困难，我们决定让供应商来完成。</p>
<p>现在市场上有两家供应商：FastDoc Soft的产品便宜，并且转换速度快，而GoodDoc Soft的产品贵，但转换效果好。我们决定同时使用这两家供应商的产品，以便给免费用户和付费用户提供不同的服务。</p>
<p>我们先看看FastDoc Soft的产品是如何实现的。首先，FastDoc Soft必须要有实际的产品，即<code>FastHtmlDocument</code>和<code>FastWordDocument</code>：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastHtmlDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HtmlDocument</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toHtml</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException </span>{</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastWordDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WordDocument</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Path path)</span> <span class="hljs-keyword">throws</span> IOException </span>{</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，FastDoc Soft必须提供一个实际的工厂来生产这两种产品，即<code>FastFactory</code>：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HtmlDocument <span class="hljs-title">createHtml</span><span class="hljs-params">(String md)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FastHtmlDocument(md);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> WordDocument <span class="hljs-title">createWord</span><span class="hljs-params">(String md)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FastWordDocument(md);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样，我们就可以使用FastDoc Soft的服务了。客户端编写代码如下：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 创建AbstractFactory，实际类型是FastFactory:</span></span><br><span class="line">AbstractFactory factory = <span class="hljs-keyword">new</span> FastFactory();</span><br><span class="line"><span class="hljs-comment">// 生成Html文档:</span></span><br><span class="line">HtmlDocument html = factory.createHtml(<span class="hljs-string">"#Hello\nHello, world!"</span>);</span><br><span class="line">html.save(Paths.get(<span class="hljs-string">"."</span>, <span class="hljs-string">"fast.html"</span>));</span><br><span class="line"><span class="hljs-comment">// 生成Word文档:</span></span><br><span class="line">WordDocument word = factory.createWord(<span class="hljs-string">"#Hello\nHello, world!"</span>);</span><br><span class="line">word.save(Paths.get(<span class="hljs-string">"."</span>, <span class="hljs-string">"fast.doc"</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们要同时使用GoodDoc Soft的服务怎么办？因为用了抽象工厂模式，GoodDoc Soft只需要根据我们定义的抽象工厂和抽象产品接口，实现自己的实际工厂和实际产品即可：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 实际工厂:</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AbstractFactory</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HtmlDocument <span class="hljs-title">createHtml</span><span class="hljs-params">(String md)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GoodHtmlDocument(md);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> WordDocument <span class="hljs-title">createWord</span><span class="hljs-params">(String md)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GoodWordDocument(md);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 实际产品:</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodHtmlDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HtmlDocument</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodWordDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HtmlDocument</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端要使用GoodDoc Soft的服务，只需要把原来的<code>new FastFactory()</code>切换为<code>new GoodFactory()</code>。</p>
<p>注意到，客户端代码除了通过new创建了<code>FastFactory</code>和<code>GoodFactory</code>外，其余代码只引用了产品接口，并未引用任何实际产品。如果把创建工厂的代码放到<code>AbstractFactory</code>中，就可以连实际工厂也屏蔽了。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AbstractFactory</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractFactory <span class="hljs-title">createFactory</span><span class="hljs-params">(String name)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (name.equalsIgnoreCase(<span class="hljs-string">"fast"</span>)) {</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FastFactory();</span><br><span class="line">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.equalsIgnoreCase(<span class="hljs-string">"good"</span>)) {</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GoodFactory();</span><br><span class="line">        } <span class="hljs-keyword">else</span> {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Invalid factory name"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器模式（Builder）是使用多个“小型工厂”来最终创建出一个完整对象。当我们使用Builder时，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>
<p>我们仍然以Markdown转HTML为例，因为直接编写一个完整的转换器比较困难，但如果针对类似下面的一行文本：</p>
<figure class="highlight markdown hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section"># this is a heading</span></span><br></pre></td></tr></tbody></table></figure>

<p>转换成HTML就很简单：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;<span class="hljs-keyword">this</span> is a heading&lt;/h1&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>因此，我们把Markdown转HTML看作一行一行转换，每一行根据语法，使用不同的转换器：</p>
<ul>
<li>如果以<code>#</code>开头，使用<code>HeadingBuilder</code>转换</li>
<li>如果以<code>&gt;</code>开头，使用<code>QuoteBuilder</code>转换</li>
<li>如果以<code>---</code>开头，使用<code>HrBuilder</code>转换</li>
<li>其余使用<code>ParagraphBuilder</code>转换</li>
</ul>
<p>这个HtmlBuilder写出来如下：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HtmlBuilder</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> HeadingBuilder headingBuilder = <span class="hljs-keyword">new</span> HeadingBuilder();</span><br><span class="line">    <span class="hljs-keyword">private</span> HrBuilder hrBuilder = <span class="hljs-keyword">new</span> HrBuilder();</span><br><span class="line">    <span class="hljs-keyword">private</span> ParagraphBuilder paragraphBuilder = <span class="hljs-keyword">new</span> ParagraphBuilder();</span><br><span class="line">    <span class="hljs-keyword">private</span> QuoteBuilder quoteBuilder = <span class="hljs-keyword">new</span> QuoteBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toHtml</span><span class="hljs-params">(String markdown)</span> </span>{</span><br><span class="line">        StringBuilder buffer = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">        markdown.lines().forEach(line -&gt; {</span><br><span class="line">            <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">"#"</span>)) {</span><br><span class="line">                buffer.append(headingBuilder.buildHeading(line)).append(<span class="hljs-string">'\n'</span>);</span><br><span class="line">            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">"&gt;"</span>)) {</span><br><span class="line">                buffer.append(quoteBuilder.buildQuote(line)).append(<span class="hljs-string">'\n'</span>);</span><br><span class="line">            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (line.startsWith(<span class="hljs-string">"---"</span>)) {</span><br><span class="line">                buffer.append(hrBuilder.buildHr(line)).append(<span class="hljs-string">'\n'</span>);</span><br><span class="line">            } <span class="hljs-keyword">else</span> {</span><br><span class="line">                buffer.append(paragraphBuilder.buildParagraph(line)).append(<span class="hljs-string">'\n'</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="hljs-keyword">return</span> buffer.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意观察上述代码，<code>HtmlBuilder</code>并不是一次性把整个Markdown转换为HTML，而是一行一行转换，而且它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个<code>XxxBuilder</code>去转换。最后，把所有转换的结果组合起来，返回给客户端。</p>
<p>这样一来，我们只需要针对每一种类型编写不同的Builder。例如，针对以<code>#</code>开头的行，需要<code>HeadingBuilder</code>：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeadingBuilder</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">buildHeading</span><span class="hljs-params">(String line)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">while</span> (line.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'#'</span>) {</span><br><span class="line">            n++;</span><br><span class="line">            line = line.substring(<span class="hljs-number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"&lt;h%d&gt;%s&lt;/h%d&gt;"</span>, n, line.strip(), n);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：实际解析Markdown是带有状态的，即下一行的语义可能与上一行相关。这里我们做了简化，认为每一行可以独立转换。</p>
</blockquote>
<p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p>
<p>JavaMail的<code>MimeMessage</code>就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是<code>MimeMessage</code>：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Multipart multipart = <span class="hljs-keyword">new</span> MimeMultipart();</span><br><span class="line"><span class="hljs-comment">// 添加text:</span></span><br><span class="line">BodyPart textpart = <span class="hljs-keyword">new</span> MimeBodyPart();</span><br><span class="line">textpart.setContent(body, <span class="hljs-string">"text/html;charset=utf-8"</span>);</span><br><span class="line">multipart.addBodyPart(textpart);</span><br><span class="line"><span class="hljs-comment">// 添加image:</span></span><br><span class="line">BodyPart imagepart = <span class="hljs-keyword">new</span> MimeBodyPart();</span><br><span class="line">imagepart.setFileName(fileName);</span><br><span class="line">imagepart.setDataHandler(<span class="hljs-keyword">new</span> DataHandler(<span class="hljs-keyword">new</span> ByteArrayDataSource(input, <span class="hljs-string">"application/octet-stream"</span>)));</span><br><span class="line">multipart.addBodyPart(imagepart);</span><br><span class="line"></span><br><span class="line">MimeMessage message = <span class="hljs-keyword">new</span> MimeMessage(session);</span><br><span class="line"><span class="hljs-comment">// 设置发送方地址:</span></span><br><span class="line">message.setFrom(<span class="hljs-keyword">new</span> InternetAddress(<span class="hljs-string">"me@example.com"</span>));</span><br><span class="line"><span class="hljs-comment">// 设置接收方地址:</span></span><br><span class="line">message.setRecipient(Message.RecipientType.TO, <span class="hljs-keyword">new</span> InternetAddress(<span class="hljs-string">"xiaoming@somewhere.com"</span>));</span><br><span class="line"><span class="hljs-comment">// 设置邮件主题:</span></span><br><span class="line">message.setSubject(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"UTF-8"</span>);</span><br><span class="line"><span class="hljs-comment">// 设置邮件内容为multipart:</span></span><br><span class="line">message.setContent(multipart);</span><br></pre></td></tr></tbody></table></figure>

<p>很多时候，我们可以简化Builder模式，以链式调用的方式来创建对象。例如，我们经常这样编写代码：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">builder.append(secure ? <span class="hljs-string">"https://"</span> : <span class="hljs-string">"http://"</span>)</span><br><span class="line">       .append(<span class="hljs-string">"www.liaoxuefeng.com"</span>)</span><br><span class="line">       .append(<span class="hljs-string">"/"</span>)</span><br><span class="line">       .append(<span class="hljs-string">"?t=0"</span>);</span><br><span class="line">String url = builder.toString();</span><br></pre></td></tr></tbody></table></figure>

<p>由于我们经常需要构造URL字符串，可以使用Builder模式编写一个URLBuilder，调用方式如下：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String url = URLBuilder.builder() <span class="hljs-comment">// 创建Builder</span></span><br><span class="line">        .setDomain(<span class="hljs-string">"www.liaoxuefeng.com"</span>) <span class="hljs-comment">// 设置domain</span></span><br><span class="line">        .setScheme(<span class="hljs-string">"https"</span>) <span class="hljs-comment">// 设置scheme</span></span><br><span class="line">        .setPath(<span class="hljs-string">"/"</span>) <span class="hljs-comment">// 设置路径</span></span><br><span class="line">        .setQuery(Map.of(<span class="hljs-string">"a"</span>, <span class="hljs-string">"123"</span>, <span class="hljs-string">"q"</span>, <span class="hljs-string">"K&amp;R"</span>)) <span class="hljs-comment">// 设置query</span></span><br><span class="line">        .build(); <span class="hljs-comment">// 完成build</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>原型模式，即Prototype，指创建新对象的时候，根据现有的一个原型创建。</p>
<p>我们举个例子：如果我们已经有了一个<code>String[]</code>数组，想再创建一个一模一样的<code>String[]</code>数组，怎么写？实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 原型:</span></span><br><span class="line">String[] original = { <span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Pear"</span>, <span class="hljs-string">"Banana"</span> };</span><br><span class="line"><span class="hljs-comment">// 新对象:</span></span><br><span class="line">String[] copy = Arrays.copyOf(original, original.length);</span><br></pre></td></tr></tbody></table></figure>

<p>对于普通类，我们如何实现原型拷贝？Java的Object提供了一个<code>clone()</code>方法，它的意图就是复制一个新的对象出来，我们需要实现一个<code>Cloneable</code>接口，来标识一个对象是“可复制”的。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 复制新对象并返回:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        Student std = <span class="hljs-keyword">new</span> Student();</span><br><span class="line">        std.id = <span class="hljs-keyword">this</span>.id;</span><br><span class="line">        std.name = <span class="hljs-keyword">this</span>.name;</span><br><span class="line">        std.score = <span class="hljs-keyword">this</span>.score;</span><br><span class="line">        <span class="hljs-keyword">return</span> std;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用的时候，因为clone()的方法签名定义在Object中，返回类型也是Object，所以强制转型，比较麻烦。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student std1 = <span class="hljs-keyword">new</span> Student();</span><br><span class="line">std1.setId(<span class="hljs-number">123</span>);</span><br><span class="line">std1.setName(<span class="hljs-string">"Bob"</span>);</span><br><span class="line">std1.setScore(<span class="hljs-number">88</span>);</span><br><span class="line"><span class="hljs-comment">// 复制新对象:</span></span><br><span class="line">Student std2 = (Student) std1.clone();</span><br></pre></td></tr></tbody></table></figure>

<p>实际上，使用原型模式更好的方式是定义一个<code>copy()</code>方法，返回明确的类型。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">copy</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        Student std = <span class="hljs-keyword">new</span> Student();</span><br><span class="line">        std.id = <span class="hljs-keyword">this</span>.id;</span><br><span class="line">        std.name = <span class="hljs-keyword">this</span>.name;</span><br><span class="line">        std.score = <span class="hljs-keyword">this</span>.score;</span><br><span class="line">        <span class="hljs-keyword">return</span> std;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>单例模式，即Singleton，是为了保证在一个进程中，某个类有且仅有一个实例。因为这个类只有一个实例，因此，自然不能让调用方使用<code>new Xyz()</code>来创建实例了。所以，单例的构造方法必须是<code>private</code>，这样就防止了调用方自己创建实例。但在类的内部，可以用一个静态字段来引用唯一创建的实例。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>那么，外部调用方如何获取这唯一的实例呢？提供一个静态方法返回这个实例。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 通过静态方法返回实例:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>或者直接把static变量暴露出去。</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以，单例模式的实现方式很简单：</p>
<ol>
<li>只有<code>private</code>构造方法，确保外部无法实例化；</li>
<li>通过<code>private static</code>变量持有唯一实例，保证全局唯一性；</li>
<li>通过<code>public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li>
</ol>
<p>Java标准库有一些类就是单例，例如<code>Runtime</code>这个类：</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = Runtime.getRuntime();</span><br></pre></td></tr></tbody></table></figure>

<p>有些童鞋可能听说过延迟加载，即在调用方第一次调用<code>getInstance()</code>时才初始化全局唯一实例，类似这样：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton INSTANCE = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) {</span><br><span class="line">            INSTANCE = <span class="hljs-keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>遗憾的是，这种写法在多线程中是错误的，在竞争条件下会创建出多个实例。必须对整个方法进行加锁：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) {</span><br><span class="line">        INSTANCE = <span class="hljs-keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> INSTANCE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但加锁会严重影响并发性能。还有些童鞋听说过双重检查，类似这样：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) {</span><br><span class="line">        <span class="hljs-keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">            <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) {</span><br><span class="line">                INSTANCE = <span class="hljs-keyword">new</span> Singleton();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> INSTANCE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然而，由于Java的内存模型，双重检查在这里不成立。要真正实现延迟加载，只能通过Java的ClassLoader机制完成。如果没有特殊的需求，使用Singleton模式的时候，最好不要延迟加载，这样会使代码更简单。</p>
<p>另一种实现Singleton的方式是利用Java的<code>enum</code>，因为Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">World</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 唯一枚举:</span></span><br><span class="line">	INSTANCE;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">private</span> String name = <span class="hljs-string">"world"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{</span><br><span class="line">		<span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个<code>World</code>类在调用方看来就可以这么用：</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = World.INSTANCE.getName();</span><br></pre></td></tr></tbody></table></figure>

<p>使用枚举实现Singleton还避免了第一种方式实现Singleton的一个潜在问题：即序列化和反序列化会绕过普通类的<code>private</code>构造方法从而创建出多个实例，而枚举类就没有这个问题。</p>
<p>那我们什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code>new</code>操作符：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 表示一个单例组件</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>Singleton模式是为了保证一个程序的运行期间，某个类有且只有一个全局唯一实例；</p>
<p>Singleton模式既可以严格实现，也可以以约定的方式把普通类视作单例。</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式主要涉及如何组合各种对象一遍获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合和运行期的动态组合来实现更灵活的功能。</p>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B结构，但是待传入的对象却是A接口，怎么办？</p>
<blockquote>
<p>如果去美国，我们随身带的电器是无法直接使用的，因为美国的插座标准和中国不同，所以，我们需要一个适配器</p>
</blockquote>
<p>在程序设计中，适配器也是类似的。我们已经有一个<code>Task</code>类，实现了<code>Callable</code>接口：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Long</span>&gt; </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> num;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(<span class="hljs-keyword">long</span> num)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">this</span>.num = num;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="hljs-keyword">long</span> r = <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> n = <span class="hljs-number">1</span>; n &lt;= <span class="hljs-keyword">this</span>.num; n++) {</span><br><span class="line">            r = r + n;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="hljs-string">"Result: "</span> + r);</span><br><span class="line">        <span class="hljs-keyword">return</span> r;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，我们想通过一个线程去执行它：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Long&gt; callable = <span class="hljs-keyword">new</span> Task(<span class="hljs-number">123450000L</span>);</span><br><span class="line">Thread thread = <span class="hljs-keyword">new</span> Thread(callable); <span class="hljs-comment">// compile error!</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></tbody></table></figure>

<p>发现编译不过！因为<code>Thread</code>接收<code>Runnable</code>接口，但不接收<code>Callable</code>接口，怎么办？一个办法是改写Task类，把实现的<code>Callable</code>改为<code>Runnable</code>，但这样做不好，因为Task很可能在其他地方作为Callable被调用，改写Task的接口，会导致其他正常工作的代码无法编译。</p>
<p>另一个办法不用改写<code>Task</code>类，而是用一个Adapter，把这个<code>Callable</code>接口“变成”<code>Runnable</code>接口，这样，就可以正常编译：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Long&gt; callable = <span class="hljs-keyword">new</span> Task(<span class="hljs-number">123450000L</span>);</span><br><span class="line">Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> RunnableAdapter(callable));</span><br><span class="line">thread.start();</span><br></pre></td></tr></tbody></table></figure>

<p>这个<code>RunnableAdapter</code>类就是Adapter，它接收一个<code>Callable</code>，输出一个<code>Runnable</code>。怎么实现这个<code>RunnableAdapter</code>呢？我们先看完整的代码：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 引用待转换接口:</span></span><br><span class="line">    <span class="hljs-keyword">private</span> Callable&lt;?&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RunnableAdapter</span><span class="hljs-params">(Callable&lt;?&gt; callable)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">this</span>.callable = callable;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 实现指定接口:</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-comment">// 将指定接口调用委托给转换接口调用:</span></span><br><span class="line">        <span class="hljs-keyword">try</span> {</span><br><span class="line">            callable.call();</span><br><span class="line">        } <span class="hljs-keyword">catch</span> (Exception e) {</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编写一个Adapter的步骤如下：</p>
<ol>
<li>实现目标接口，这里是<code>Runnable</code></li>
<li>内部持有一个待转换接口的引用，这里是通过字段持有<code>Callable</code>接口</li>
<li>在目标接口的实现方法内部，调用待转换接口的方法</li>
</ol>
<p>这样一来，Thread就可以接收这个<code>RunnableAdapter</code>，因为它实现了<code>Runnable</code>接口。<code>Thread</code>作为调用方，它会调用<code>RunnableAdapter</code>的<code>run()</code>方法，在这个<code>run()</code>方法内部，又调用了<code>Callable</code>的<code>call()</code>方法，相当于<code>Thread</code>通过一层转换，间接调用了<code>Callable</code>的<code>call()</code>方法。</p>
<p>适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是<code>String[]</code>，但是需要<code>List</code>接口时，可以用一个Adapter：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] exist = <span class="hljs-keyword">new</span> String[] {<span class="hljs-string">"Good"</span>, <span class="hljs-string">"morning"</span>, <span class="hljs-string">"Bob"</span>, <span class="hljs-string">"and"</span>, <span class="hljs-string">"Alice"</span>};</span><br><span class="line">Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(exist));</span><br></pre></td></tr></tbody></table></figure>

<p>注意到<code>List&lt;T&gt; Arrays.asList(T[])</code>就相当于一个转换器，它可以把数组转换为<code>List</code>。</p>
<p>我们再看一个例子：假设我们持有一个<code>InputStream</code>，希望调用<code>readText(Reader)</code>方法，但它的参数类型是<code>Reader</code>而不是<code>InputStream</code>，怎么办？</p>
<p>当然是使用适配器，把<code>InputStream</code>“变成”<code>Reader</code>：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = Files.newInputStream(Paths.get(<span class="hljs-string">"/path/to/file"</span>));</span><br><span class="line">Reader reader = <span class="hljs-keyword">new</span> InputStreamReader(input, <span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">readText(reader);</span><br></pre></td></tr></tbody></table></figure>

<p><code>InputStreamReader</code>就是Java标准库提供的<code>Adapter</code>，它负责把一个<code>InputStream</code>适配为<code>Reader</code>。类似的还有<code>OutputStreamWriter</code>。</p>
<p>如果我们把<code>readText(Reader)</code>方法参数从<code>Reader</code>改为<code>FileReader</code>，会有什么问题？这个时候，因为我们需要一个<code>FileReader</code>类型，就必须把<code>InputStream</code>适配为<code>FileReader</code>：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileReader reader = <span class="hljs-keyword">new</span> InputStreamReader(input, <span class="hljs-string">"UTF-8"</span>); <span class="hljs-comment">// compile error!</span></span><br></pre></td></tr></tbody></table></figure>

<p>直接使用<code>InputStreamReader</code>这个Adapter是不行的，因为它只能转换出<code>Reader</code>接口。事实上，要把<code>InputStream</code>转换为<code>FileReader</code>也不是不可能，但需要花费十倍以上的功夫。这时，面向抽象编程这一原则就体现出了威力：持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。<strong>一旦持有某个具体的子类类型，要想做一些改动就非常困难</strong>。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>Adapter模式可以将一个A接口转换为B接口。编写Adapter实际上就是编写了一个实现了B接口，并且内部持有A接口的类，在Adapter内部将B接口的调用“转换”为A接口的调用。<strong>只有A、B接口均是抽象接口时，才能非常简单地实现Adapter模式</strong>。</p>
<h3 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h3><p>桥接模式的定义非常玄乎，直接理解不太容易，所以我们还是举例子。</p>
<blockquote>
<p>假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类。如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。所以，桥接模式就是为了避免直接继承带来的子类爆炸。</p>
</blockquote>
<p>我们来看看桥接模式如何解决上述问题。</p>
<p>在桥接模式中，首先把<code>Car</code>按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。我们来看看具体的实现。</p>
<p>首先定义抽象类<code>Car</code>，它引用一个<code>Engine</code>：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 引用Engine:</span></span><br><span class="line">    <span class="hljs-keyword">protected</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(Engine engine)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">this</span>.engine = engine;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drive</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Engine</code>的定义如下：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Engine</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>紧接着，在一个“修正”的抽象类<code>RefinedCar</code>中定义一些额外操作：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RefinedCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RefinedCar</span><span class="hljs-params">(Engine engine)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">super</span>(engine);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drive</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">this</span>.engine.start();</span><br><span class="line">        System.out.println(<span class="hljs-string">"Drive "</span> + getBrand() + <span class="hljs-string">" car..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getBrand</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样一来，最终的不同品牌继承自<code>RefinedCar</code>，例如<code>BossCar</code>：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BossCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RefinedCar</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BossCar</span><span class="hljs-params">(Engine engine)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">super</span>(engine);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBrand</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"Boss"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而针对每一种引擎，继承自<code>Engine</code>，例如<code>HybridEngine</code>：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HybridEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Engine</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="hljs-string">"Start Hybrid Engine..."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的Car：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RefinedCar car = <span class="hljs-keyword">new</span> BossCar(<span class="hljs-keyword">new</span> HybridEngine());</span><br><span class="line">car.drive();</span><br></pre></td></tr></tbody></table></figure>

<p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对<code>Engine</code>派生一个新的子类，如果要增加一个品牌，只需要针对<code>RefinedCar</code>派生一个子类，任何<code>RefinedCar</code>的子类都可以和任何一种<code>Engine</code>自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p>
<p>桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p>
<p><strong>桥接模式通过分离一个抽象接口和它的实现部分，使得设计可以按两个维度独立扩展</strong>。</p>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶节点和父节点统一起来处理。举个例子，在XML和HTML中，从根结点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一棵树。</p>
<p>要以树的结构表示XML，我们可以先抽象出节点类型Node。对于一个<code>&lt;abc&gt;</code>这样的节点，我们称之为ElementNode，他可以包含任意个子节点。而对于普通文本，我们把它看作TextNode，它没有子节点。此外，还可以有注释节点。</p>
<p>通过ElementNode、TextNode和CommentNode，我们就可以构造出一棵树。</p>
<p>类似地，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义。</p>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器模式（Decorator），是一种在运行期动态给某个对象的实例增加功能的方法。</p>
<p>我们在IO的<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1298364142452770">Filter模式</a>一节中其实已经讲过装饰器模式了。在Java标准库中，<code>InputStream</code>是抽象类，<code>FileInputStream</code>、<code>ServletInputStream</code>、<code>Socket.getInputStream()</code>这些<code>InputStream</code>都是最终数据源。</p>
<p>现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。</p>
<p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。</p>
<p>例如：给<code>FileInputStream</code>增加缓冲和解压缩功能，用Decorator模式写出来如下：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 创建原始的数据源:</span></span><br><span class="line">InputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.gz"</span>);</span><br><span class="line"><span class="hljs-comment">// 增加缓冲功能:</span></span><br><span class="line">InputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis);</span><br><span class="line"><span class="hljs-comment">// 增加解压缩功能:</span></span><br><span class="line">InputStream gis = <span class="hljs-keyword">new</span> GZIPInputStream(bis);</span><br></pre></td></tr></tbody></table></figure>

<p>或者一次性写成这样：</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="hljs-keyword">new</span> GZIPInputStream( <span class="hljs-comment">// 第二层装饰</span></span><br><span class="line">                        <span class="hljs-keyword">new</span> BufferedInputStream( <span class="hljs-comment">// 第一层装饰</span></span><br><span class="line">                            <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"test.gz"</span>) <span class="hljs-comment">// 核心功能</span></span><br><span class="line">                        ));</span><br></pre></td></tr></tbody></table></figure>

<p>观察<code>BufferedInputStream</code>和<code>GZIPInputStream</code>，它们实际上都是从<code>FilterInputStream</code>继承的，这个<code>FilterInputStream</code>就是一个抽象的Decorator。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是<code>FilterInputStream</code>。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是<code>BufferedInputStream</code>、<code>GZIPInputStream</code>等。</p>
<p>Decorator模式有什么好处？它实际上把核心功能和附加功能给分开了。核心功能指<code>FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如<code>ByteInputStream</code>。如果我们要增加附加功能，就增加Decorator的子类，例如<code>CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>
<h3 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h3><p>外观模式，即Facade，它的基本思想是：如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p>
<p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code>RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p>
<p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</p>
<h3 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h3><p>享元（Flyweight）的核心思想很简单，如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p>
<p>享元模式在Java标准库中有很多应用。我们知道，包装类型如<code>Byte</code>、<code>Integer</code>都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以<code>Integer</code>为例，如果我们通过<code>Integer.valueOf()</code>这个静态工厂方法创建<code>Integer</code>实例，当传入的<code>int</code>范围在<code>-128</code>~`+127<code>之间时，会直接返回缓存的</code>Integer<code>实例。对于</code>Byte<code>来说，因为它一共只有256个状态，所以，通过</code>Byte.valueOf()<code>创建的</code>Byte`实例，全部都是缓存对象。</p>
<p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。</p>
<p>在实际应用中，享元模式主要应用于缓存，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。</p>
<p>在实际应用中，我们经常使用成熟的缓存库，例如<a target="_blank" rel="noopener" href="https://github.com/google/guava">Guava</a>的<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/Cache.java">Cache</a>，因为它提供了最大缓存数量限制、定时过期等实用功能。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理模式，即Proxy，它和Adapter模式很相似。Adapter模式用于把A接口转换为B接口，而Proxy模式把A接口转为A接口，Proxy就是给A接口再包一层。</p>
<figure class="highlight plaintext hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public AProxy implements A {</span><br><span class="line">    private A a;</span><br><span class="line">    public AProxy(A a) {</span><br><span class="line">        this.a = a;</span><br><span class="line">    }</span><br><span class="line">    public void a() {</span><br><span class="line">    if (getCurrentUser().isRoot()) {</span><br><span class="line">        this.a.a();</span><br><span class="line">    } else {</span><br><span class="line">        throw new SecurityException("Forbidden");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们在调用<code>this.a.a()</code>的前后，加了一些额外代码。这样一来，我们就可以实现权限检查，只有复合要求的用户，才会真正调用目标方法，否则会直接抛出异常。</p>
<p>为啥不把权限检查的功能直接写到目标实例A的内部？</p>
<p>因为我们编写代码的原则有：</p>
<ul>
<li>职责清晰：一个类只负责一件事；</li>
<li>易于测试：一次只测一个功能。</li>
</ul>
<p>用Proxy实现这个权限检查，我们可以获得更清晰、更简洁的代码：</p>
<ul>
<li>A接口：只定义接口；</li>
<li>ABusiness类：只实现A接口的业务逻辑；</li>
<li>APermissionProxy类：只实现A接口的权限检查代理。</li>
</ul>
<p>如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。</p>
<p>实际上权限检查只是代理模式的一种应用。Proxy还广泛应用在：</p>
<h4 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h4><p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p>
<h4 id="虚代理"><a href="#虚代理" class="headerlink" title="虚代理"></a>虚代理</h4><p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p>
<h4 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h4><p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p>
<h4 id="智能引用"><a href="#智能引用" class="headerlink" title="智能引用"></a>智能引用</h4><p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>有的童鞋会发现Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p>
<p>代理模式通过封装一个已有接口，并向调用方返回相同的接口类型，能让调用方在不改变任何代码的前提下增强某些功能（例如，鉴权、延迟加载、连接池复用等）。使用Proxy模式要求调用方持有接口，作为Proxy的类也必须实现相同的接口类型。</p>
</body></html>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop is-hidden-mobile article-nav-prev">
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2021/06/05/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%97%A5%E8%AE%B0/">第一篇日记</a>
            
        </span>
    </div>
    
</article>


<div class="sharebox">
    
<div class="sharethis-inline-share-buttons"></div>
<script type='text/javascript' src='//platform-api.sharethis.com/js/sharethis.js#property=608c1408daac690012507aa2&amp;product=sop' async='async'></script>

</div>



    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2021 WanZixin&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        target="_blank" rel="noopener" href="http://github.com/ppoffice/hexo-theme-minos">Minos</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                
                    
                <a class="column is-narrow has-text-black" title="GitHub" target="_blank" rel="noopener" href="https://github.com/ppoffice/hexo-theme-minos">
                    
                    GitHub
                    
                </a>
                
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("en-AU");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="/js/insight.js"></script>

    
</body>
</html>